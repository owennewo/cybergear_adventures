/**
 * CYBERGEAR SPI1 BITBANG
 * ----------------------
 * SPI1 is connected to a single device, the Infineon 6EDL7141
 * This device has a 24bit word length, and is tricky to use with a gd32 which
 * is more comfortable with 8bit and 16bit words.
 *
 * This example uses the SoftwareSPI library to bitbang the SPI1 interface which can handle
 * various word lengths.
 *
 */
#include "SoftwareSPI.h"
#include "Wire.h"
#include <Arduino.h>
#include "SimpleCAN.h"
#include "drivers/infineon_6EDL7141/infineon_6EDL7141.h"
#include "PinNamesVar.h"

PinName SPI1_MOSI = PORTB_15;
PinName SPI1_MISO = PORTB_14;
PinName SPI1_SCK = PORTB_13;
PinName SPI1_CS = PORTB_12;
// SPIClass spi(DIGITAL_TO_PINNAME(A_SPI1_MOSI), DIGITAL_TO_PINNAME(A_SPI1_MISO), DIGITAL_TO_PINNAME(A_SPI1_SCK), DIGITAL_TO_PINNAME(A_SPI1_CS));
SPIClass spi(SPI1_MOSI, SPI1_MISO, SPI1_SCK, SPI1_CS);

Infineon6EDL7141Driver3PWM driver = Infineon6EDL7141Driver3PWM(A_INHA, A_INHB, A_INHC, PB12, false, A_EN_DRV);

void setup()
{
  pinMode(PB15, OUTPUT);
  pinMode(PB14, INPUT);
  pinMode(PB13, OUTPUT);
  pinMode(PB12, OUTPUT);

  CAN.begin(1000000);
  // spi.begin();
  driver.init(&spi);
}

static uint8_t data[8];

uint8_t temp_reg = 0x01; // TEMP STATUS

void loop()
{

  // driver.clearFaults(true, true);

  uint16_t reg1 = driver.readFaultStatus().reg;
  uint16_t reg2 = driver.readTemperatureStatus().reg;
  uint16_t reg3 = driver.readVoltateSupplyStatus().reg;
  uint16_t reg4 = driver.readFunctionStatus().reg;

  // uint16_t reg1 = driver.readOneTimeProgramStatus().reg;
  // uint16_t reg2 = driver.readADCStatus().reg;
  // uint16_t reg3 = driver.readChargePumpStatus().reg;
  // uint16_t reg4 = driver.readDeviceID().reg;

  // PWMCfgRegister config = driver.readPWMConfigRegister();
  // uint16_t reg1 = config.reg;
  // config.setPWMMode(PWMMode::PWM3_Mode);
  // uint16_t reg2 = config.reg;

  // PWMCfgRegister config2 = {};
  // config2.PWM_MODE = PWMMode::PWM3_Mode;
  // config2.BRAKE_CFG = BrakeConfig::BrakeToggle;
  // config2.setOnePWMFreewheel(OnePWMFreewheel::Diode);
  // config2.setOnePwmHallRecirculating(true);
  // uint16_t reg3 = config2.reg;
  // driver.writePWMConfigRegister(config2);
  // uint16_t reg4 = driver.readPWMConfigRegister().reg;

  data[0] = uint8_t(reg1 >> 8);
  data[1] = uint8_t(reg1 & 0xFF);
  data[2] = uint8_t(reg2 >> 8);
  data[3] = uint8_t(reg2 & 0xFF);
  data[4] = uint8_t(reg3 >> 8);
  data[5] = uint8_t(reg3 & 0xFF);
  data[6] = uint8_t(reg4 >> 8);
  data[7] = uint8_t(reg4 & 0xFF);

  bool isRtr = false;
  CanMsg txMsg = CanMsg(
      CanExtendedId(0b111111111111110, isRtr),
      8,
      data);

  CAN.write(txMsg);

  delay(900);

  while (true)
    ;
}
